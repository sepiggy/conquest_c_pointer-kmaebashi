## 1 从基础开始——预备知识和复习
### 1.2 关于指针
1. 指针类型
    - `指针类型`不是单独存在的, 它是由其他类型派生而成的. 也就是说, 实际上存在的类型是 `指向int的指针类型`, `指向double的指针类型` etc.
    
2. 指针类型, 指针类型变量, 指针类型的值
    - 因为 `指针类型` 是类型, 所以它和 `int类型`, `double类型` 一样, 也存在 `指针类型变量` 和 `指针类型的值`. 三者经常都统称为 `指针`, 非常容易造成歧义, 需要根据上下文语境进行判断
    - 先有 `指针类型`, 因为有了 `指针类型`, 所以有了 `指针类型的变量` 和 `指针类型的值`
    
3. 变量不一定按照声明的顺序保存在内存中

4. 指针运算
    - 指针运算是针对指针进行整数加减运算，以及指针之间进行减法运算的功能
    - 对指针加 `N`，指针前进 `当前指针指向的数据类型的长度 × N`
    
5. 空指针
    - 空指针是一个特殊的指针值
    - 空指针是指可以确保没有指向任何一个对象的指针, 通常使用宏定义 `NULL` 来表示空指针常量值
    - 空指针确保它和任何非空指针进行比较都不会相等，因此经常作为函数发生异常时的返回值使用
    
### 1.3 关于数组
1. 数组是指将固定个数、相同类型的变量排列起来的对象

2. 给指向数组的某个元素的指针加 N 后，指针会指向 N 个之后的元素

3. 表达式中，数组可以解读成 `指向它的初始元素的指针`; 尽管有三个小例外，但是这和在后面加不加`[]`没有关系

4. p[i] 与 *(p + i)
    - `p[i]` 是 `*(p + i)` 的简便写法, `p[i]` 的写法就是一种语法糖, 下标运算符 `[]` 原本就有这种用法，它和数组无关
    
    - 根据加法交换率 `*(p + i)` 等价于 `*(i + p)`; 相应地, `p[i]` 可以写成 `i[p]`, 但是不要这样写
    
5. 将数组作为函数的参数进行传递 ?
    - 在 C 中是不能将数组作为函数参数进行传递的; 但是，你可以 `通过传递指向初始元素的指针来达到将数组作为参数进行传递的目的`
    - 在 C 中，函数参数传递都是传值，向函数传递的都是参数的副本
    - 无论如何都要将数组进行值传递的时候，建议将数组整体整理成结构体成员

6. 数组作为函数的形参进行声明
    - 只有在声明函数形参时，数组的声明才被编译器解读成指针, 即 `int func(int a[])` 等价于 `int func(int *a)`, 即使定义了元素个数, 编译器也是无视的, `int func(int a[10])` 也与前两者等价

## 2 做个实验见分晓——C 是怎么使用内存的
### 2.1 虚拟地址
1. 当今的操作系统都会给应用程序的每一个进程分配独立的 `虚拟地址空间`. 这和 C 语言本身并没有关系，而是操作系统和 CPU 协同工作的结果.

2. fflush() 是对输出流使用的, 它不能用于输入流

### 2.2 C 的内存的使用方法
1. C 语言的 `三种变量作用域`
    - 全局变量
        - 在函数之外声明的变量，默认地会成为全局变量
        - 全局变量在任何地方都是可见的
        
    - 文件内部的静态变量
        - 通过 `static` 指定的变量（包括函数），对于其他源代码文件是不可见的
        - 就算对于像全局变量那样被定义在函数外面的变量，一旦添加了 `static`，作用域就只限定在当前所在的源代码文件中
        
    - 局部变量
        - 局部变量是指在函数中声明的变量
        - 局部变量只能在包含它的声明的语句块（使用{}括起来的范围）中被引用
        - 局部变量通常在它所在的语句块结束的时候被释放. 如果你不想释放某个局部变量，可以在局部变量上加上 `static` 进行声明
        
2. 在程序中，如果需要保持一些数据，必须在内存中的某个场所取得相应大小的内存区域. 总结一下，在 C 中有 `三种内存区域的寿命`
    - 静态变量
        - 静态变量的寿命从程序运行时开始，到程序关闭时结束
        - 静态变量包括:
            - 全局变量
            - 文件内的 static 变量
            - 指定 static 的局部变量
            
    - 自动变量
        - 自动变量的寿命到声明该变量的语句块执行结束为止
        - 自动变量包括:
            - 没有指定 static 的局部变量
            
    - 通过 `malloc()` 动态分配内存
        - 通过 malloc() 分配的领域的寿命到调用 free() 为止
        

### 2.3 函数和字符串常量
1. 函数自身和字符串常量被分配到内存中的 `只读内存区域`

2. 由于函数本身不可能需要改写，所以它被配置在内存的只读区域

3. 如果执行程序是只读的，在同一份程序被同时启动多次的时候，通过在物理地址上共享程序能够节约物理内存

4. 由于硬盘上已经存放了可执行程序，就算内存不足，也不需要将程序交换到虚拟内存，相反可以将程序直接从内存中销毁

5. 函数可以在表达式中被解读成 `指向函数的指针`

6. `指向函数的指针` 本质上也是指针(地址), 所以可以将它赋给指针型变量:
    ```
    // 比如有下面的函数原型：
    int func(double d);
    // 保存指向此函数的指针的变量的声明如下：
    int (*func_p)(double); 
    // 然后写成下面这样，就可以通过 func_p 调用 func，
    int (*func_p)(double);  // 声明
    func_p = func;          // 将 func 赋给 func_p
    func_p(0.5);            // 此时，func_p 等同于 func 
    ```
    
7. 将 `指向函数的指针` 保存在变量中的技术经常被运用在如下场合：
    - GUI 中的按钮控件记忆 `当自身被按下的时候需要调用的函数`
    - 根据 `指向函数的指针的数组` 对处理进行分配, 以代替 `switch case`
